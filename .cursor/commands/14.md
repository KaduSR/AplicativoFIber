Compreendido. Esta √© uma grande lista de corre√ß√µes e melhorias. Vamos seguir a sua l√≥gica e o seu modelo de prompts para resolver cada item, um por um.

O problema mais cr√≠tico √© que **as suas chamadas reais de API (login, conex√£o, etc.) est√£o a falhar**, e o aplicativo est√° a mostrar dados *placeholder* ("mockados") ou ecr√£s vazios.

Vamos resolver todos os problemas de uma vez, come√ßando pela **Tarefa 14**.

-----

### Tarefa 14: Corre√ß√£o Geral de Conectividade e Refatora√ß√£o

**Objetivo:** Fazer o aplicativo inteiro (`AplicativoFIber`) parar de usar dados *mockados* e conectar-se com sucesso ao seu *backend* (`server.js`) para todas as suas funcionalidades (Login, Conex√£o/ONT, Not√≠cias, Chatbot).

**Contexto:** O *logout* (Tarefa 09) falhou porque o *login* real (Tarefa 08) est√° a falhar. Os bot√µes do perfil (`image_5a1c5f.png`) n√£o funcionam porque precisam de dados reais. A tela de "Conex√£o" est√° vazia porque n√£o est√° a chamar o *backend*. O Chatbot est√° a falhar no DownDetector.

Vamos corrigir a funda√ß√£o inteira.

-----

### 1\. (Backend) `backend/server.js`

**Tarefa:** Adicionar as novas rotas para Not√≠cias e Faturas/Contratos, e integrar o DownDetector no Chatbot.

**Instru√ß√µes:**
Temos de adicionar o `axios` (para chamar a API de not√≠cias) e o `cheerio` (para a alternativa do DownDetector).

1.  **Instale (no terminal, na pasta `backend/`):**

    ```bash
    npm install axios cheerio
    ```

    *(Lembre-se de fazer `git push` do `package.json` atualizado para o Render)*

2.  **Adicione as Importa√ß√µes (no topo do `server.js`):**

    ```javascript
    // Em: backend/server.js
    // ... (imports existentes)
    const { GoogleGenerativeAI } = require("@google/generative-ai");

    // --- ADICIONE ESTAS LINHAS ---
    const axios = require('axios');
    const jwt = require('jsonwebtoken');
    const base64 = require('react-native-base64');
    const cheerio = require('cheerio'); // Para o DownDetector
    // --- FIM DAS ADI√á√ïES ---
    ```

3.  **Adicione as Vari√°veis de Ambiente (no topo):**
    Adicione a sua `NEWS_API_KEY` (veja abaixo) e o `IXC_API_URL` ao bloco de vari√°veis.

    ```javascript
    // Em: backend/server.js

    // ... (inicializa√ß√£o do genAI)

    // --- MODIFIQUE ESTE BLOCO ---
    // (Adicione IXC_API_URL, IXC_ADMIN_TOKEN, JWT_SECRET, NEWS_API_KEY)
    const IXC_API_URL = process.env.IXC_API_URL || 'https://centralfiber.online/webservice/v1';
    const IXC_ADMIN_TOKEN = process.env.IXC_ADMIN_TOKEN; 
    const JWT_SECRET = process.env.JWT_SECRET;
    const NEWS_API_KEY = process.env.NEWS_API_KEY; // <-- ADICIONE (Obtenha em gnews.io)
    // --- FIM DA MODIFICA√á√ÉO ---

    // ... (c√≥digo do ixcApi e ixcPostList)
    ```

4.  **Refatore a Rota `/api/bot` (Chatbot):**
    **Substitua** a sua rota `app.post('/api/bot', ...)` existente por esta nova vers√£o, que agora entende o "Discord" e verifica o DownDetector.

    ```javascript
    // Em: backend/server.js

    // --- SUBSTITUA A ROTA /api/bot ---
    app.post('/api/bot', async (req, res, next) => {
      try {
        const { message, history, id_cliente } = req.body;
        if (!process.env.GEMINI_API_KEY) throw new Error('Chave Gemini n√£o configurada.');

        // --- L√ìGICA DO DOWNDETECTOR ---
        let downDetectorInfo = "";
        // Verifica se a mensagem menciona um servi√ßo (ex: Discord, Netflix, etc.)
        const servicos = ['discord', 'netflix', 'youtube', 'iptv', 'instagram', 'facebook', 'whatsapp'];
        const servicoMencionado = servicos.find(s => message.toLowerCase().includes(s));

        if (servicoMencionado) {
          console.log(`[Bot] Verificando DownDetector para: ${servicoMencionado}`);
          try {
            // Alternativa: Raspagem do site (Scraping)
            const { data } = await axios.get(`https://downdetector.com.br/fora-do-ar/${servicoMencionado}/`);
            const $ = cheerio.load(data);
            const status = $('.entry-title').first().text().trim();
            if (status) {
              downDetectorInfo = `Informa√ß√£o do DownDetector para ${servicoMencionado}: ${status}.`;
            }
          } catch (scrapeError) {
            console.error("[Bot] Falha ao raspar DownDetector:", scrapeError.message);
            downDetectorInfo = `N√£o consegui verificar o status do ${servicoMencionado} no DownDetector.`;
          }
        }
        // --- FIM DA L√ìGICA DOWNDETECTOR ---

        // (Simula√ß√£o de contexto do cliente - substitua por chamadas reais ao IXC/Genie)
        const userContext = {
          nome: "Carlos",
          plano: "Fiber Game 500MB",
          sinal_optico: "-19.2 dBm" 
        };

        const systemPrompt = `
    [Persona]
    Aja como o 'FiberBot', um assistente t√©cnico especialista da FiberNet.

    [Contexto do Cliente]
    - Nome: ${userContext.nome}
    - Plano: ${userContext.plano}
    - Sinal √ìptico (ONT): ${userContext.sinal_optico}

    [Contexto Externo]
    - ${downDetectorInfo || "Nenhuma informa√ß√£o externa solicitada."}

    [Tarefa]
    Diagnostique o problema do cliente com base no contexto.

    [Instru√ß√µes]
    - A regra mais importante: O sinal √≥ptico ideal √© acima de -25 dBm. O sinal do cliente √© ${userContext.sinal_optico}.
    - Se o sinal √≥ptico estiver bom (ex: -19 dBm), o problema N√ÉO √© o sinal f√≠sico.
    - Se o sinal estiver bom E o DownDetector reportar problemas (como o 'downDetectorInfo' mostra), informe ao cliente que o problema √© externo.
    - Se a mensagem for sobre IPTV/Streaming (Netflix, YouTube, Discord) E o sinal √≥ptico estiver bom, SEMPRE use o contexto do DownDetector.
    `;

        // (O resto da chamada ao Gemini continua igual)
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const chatHistory = history.map(msg => ({
          role: msg.role === 'user' ? 'user' : 'model',
          parts: [{ text: msg.content }],
        }));
        const chat = model.startChat({ history: chatHistory, systemInstruction: systemPrompt });
        const result = await chat.sendMessage(message);
        const text = result.response.text();
        res.json({ reply: text });

      } catch (error) {
        next(error);
      }
    });
    // --- FIM DA SUBSTITUI√á√ÉO ---
    ```

5.  **Adicione as Novas Rotas (Not√≠cias, Faturas, etc.):**
    Adicione este bloco *depois* da sua rota `/api/speedtest` e *antes* do "404 handler":

    ```javascript
    // Em: backend/server.js

    // ... (depois da rota /api/speedtest)

    // --- ROTA DE NOT√çCIAS (ITEM 4) ---
    app.get('/api/news', async (req, res, next) => {
      if (!NEWS_API_KEY) {
        return next(new Error("API de Not√≠cias n√£o configurada no servidor."));
      }
      try {
        // T√≥picos: IPTV, Jogos, Tecnologia, Fibra √ìptica, S√©ries e Filmes
        const query = "IPTV OR gaming OR technology OR 'fibra √≥ptica' OR series OR movies";
        const url = `https://gnews.io/api/v4/search?q=${encodeURIComponent(query)}&lang=pt&apikey=${NEWS_API_KEY}`;
        
        const { data } = await axios.get(url);
        res.json(data.articles || []);
      
      } catch (error) {
        console.error("Erro ao buscar not√≠cias:", error.message);
        next(error);
      }
    });

    // --- ROTAS PROTEGIDAS (Precisam de JWT) ---
    // Middleware para verificar o nosso Token JWT
    const checkAuth = (req, res, next) => {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Token n√£o fornecido.' });
      }
      const token = authHeader.split(' ')[1];
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded; // Adiciona os dados do user (id_cliente, etc.) ao 'req'
        next();
      } catch (error) {
        return res.status(401).json({ error: 'Token inv√°lido.' });
      }
    };

    // --- ROTA DE FATURAS (ITEM 2) ---
    app.get('/api/invoices', checkAuth, async (req, res, next) => {
      try {
        const requestBody = {
          qtype: 'fn_areceber.id_cliente',
          query: req.user.id_cliente, // Pega o ID do cliente (do JWT)
          oper: '=',
          page: '1', rp: '50',
          sortname: 'fn_areceber.data_vencimento', sortorder: 'desc',
        };
        const data = await ixcPostList('/fn_areceber', requestBody);
        res.json(data.registros || []);
      } catch (error) { next(error); }
    });

    // --- ROTA DE CONTRATOS (ITEM 2) ---
    app.get('/api/contracts', checkAuth, async (req, res, next) => {
      try {
        const requestBody = {
          qtype: 'cliente_contrato.id_cliente',
          query: req.user.id_cliente, // Pega o ID do cliente (do JWT)
          oper: '=',
          page: '1', rp: '10',
          sortname: 'cliente_contrato.id', sortorder: 'desc',
        };
        const data = await ixcPostList('/cliente_contrato', requestBody);
        res.json(data.registros || []);
      } catch (error) { next(error); }
    });

    // --- ROTA DE BOLETO (ITEM 2) ---
    app.get('/api/boleto/:id', checkAuth, async (req, res, next) => {
       try {
        const requestBody = {
          boletos: req.params.id, // Pega o ID da fatura (da URL)
          atualiza_boleto: 'S',
          tipo_boleto: 'arquivo',
          base64: 'S'
        };
        // '/get_boleto' n√£o √© 'listar', ent√£o usamos o 'ixcApi.post' normal
        const data = await ixcApi.post('/get_boleto', requestBody);
        res.json(data); // Retorna o JSON com o { file: "base64..." }
      } catch (error) { next(error); }
    });

    // 404 handler (Sempre por √∫ltimo...)
    // ...
    ```

-----

### 2\. (Frontend) `constants/config.ts`

**Tarefa:** Simplificar e corrigir o `config.ts`.

**Instru√ß√µes:**
**Substitua** o conte√∫do do `constants/config.ts` por isto (isto corrige a Tarefa 05 e 06):

```typescript
// Em: constants/config.ts

/**
 * A URL principal do seu backend (hospedado no Render).
 * * üõë IMPORTANTE: Substitua pela sua URL p√∫blica do Render.
 */
const API_BASE_URL = 'https://api.centralfiber.online'; // <-- COLOQUE A SUA URL DO RENDER AQUI

// Exportamos as rotas que o app vai consumir do *nosso* backend
export const API_CONFIG = {
  BASE_URL: API_BASE_URL,
  
  ENDPOINTS: {
    // Autentica√ß√£o (Tarefa 05)
    LOGIN: '/api/auth/login',

    // Rotas do IXC (Item 2)
    INVOICES: '/api/invoices',
    CONTRACTS: '/api/contracts',
    BOLETO: '/api/boleto', // (Ex: /api/boleto/12345)
    
    // Rotas de Servi√ßos
    ONT: '/api/ont',           // (Item 7)
    BOT: '/api/bot',           // (Item 5)
    SPEEDTEST: '/api/speedtest',   // (Item 7)
    NEWS: '/api/news',           // (Item 4)
  }
};
```

-----

### 3\. (Frontend) `services/ixcApi.ts`

**Tarefa:** Corrigir o `ixcApi.ts` (como na Tarefa 06).

**Instru√ß√µes:**
**Substitua** o conte√∫do do `services/ixcApi.ts` por isto:

```typescript
// Em: services/ixcApi.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { API_CONFIG } from '@/constants/config';
import AsyncStorage from '@react-native-async-storage/async-storage';

const TOKEN_STORAGE_KEY = '@FiberApp:authToken';

class ApiClient {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: API_CONFIG.BASE_URL, // Usa a URL do nosso backend
      headers: { 'Content-Type': 'application/json' },
      timeout: 20000, // Aumentado para 20s (Speedtest e Gemini podem demorar)
    });

    // Interceptor que adiciona o Token JWT em todas as requisi√ß√µes
    this.api.interceptors.request.use(async (config) => {
      const token = await AsyncStorage.getItem(TOKEN_STORAGE_KEY);
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    }, (error) => Promise.reject(error));
  }

  // Salva o Token JWT (recebido do /api/auth/login)
  public async setToken(token: string): Promise<void> {
    await AsyncStorage.setItem(TOKEN_STORAGE_KEY, token);
  }

  // Limpa o Token JWT no logout
  public async clearToken(): Promise<void> {
    await AsyncStorage.removeItem(TOKEN_STORAGE_KEY);
  }

  // M√©todos de requisi√ß√£o
  public async get<T = any>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.api.get(endpoint, config);
    return response.data;
  }

  public async post<T = any>(endpoint: string, data: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.api.post(endpoint, data, config);
    return response.data;
  }
}

// Renome√°mos 'ixcApi' para 'api' (o nosso cliente unificado)
export const api = new ApiClient();
```

-----

### 4\. (Frontend) `contexts/AuthContext.tsx`

**Tarefa:** Corrigir o *login* (Tarefa 12) e o *logout* (Tarefa 09) de uma vez por todas.

**Instru√ß√µes:**
**Substitua** o conte√∫do do `contexts/AuthContext.tsx` por isto:

```typescript
// Em: contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, ReactNode } from 'react';
import { Alert } from 'react-native';
import { authService } from '@/services/authService';
import type { IXCLoginRequest, AuthUserData } from '@/types/ixc';
import AsyncStorage from '@react-native-async-storage/async-storage';

// (O tipo do contexto muda para guardar AuthUserData)
interface AuthContextData {
  isLoading: boolean;
  user: AuthUserData | null;
  signIn: (credentials: IXCLoginRequest) => Promise<void>;
  signOut: () => void;
}

const USER_STORAGE_KEY = '@FiberApp:user';

export const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<AuthUserData | null>(null);
  const [isLoading, setIsLoading] = useState(true); // Come√ßa true

  // Efeito para carregar o utilizador salvo ao iniciar o app
  useEffect(() => {
    async function loadStorageData() {
      try {
        const storedUser = await AsyncStorage.getItem(USER_STORAGE_KEY);
        if (storedUser) {
          setUser(JSON.parse(storedUser));
        }
      } catch (e) {
        console.error("Falha ao carregar dados do utilizador", e);
      } finally {
        setIsLoading(false);
      }
    }
    loadStorageData();
  }, []);


  const signIn = async (credentials: IXCLoginRequest) => {
    setIsLoading(true);
    try {
      // 1. Tenta o login REAL (Tarefa 08)
      console.log("Tentando login real...");
      // O 'authService.login' agora chama o nosso backend
      const userData = await authService.login(credentials); 
      
      // 2. Se funcionar, define o utilizador e salva no storage
      setUser(userData);
      await AsyncStorage.setItem(USER_STORAGE_KEY, JSON.stringify(userData));

    } catch (error) {
      // 3. Se falhar, mostra o erro real (Tarefa 12)
      console.error("Falha no login real:", error);
      const errorMessage = (error instanceof Error) ? error.message : "Ocorreu um erro desconhecido.";
      Alert.alert("Erro no Login", errorMessage);
      
      // Limpa qualquer dado antigo
      setUser(null);
      await AsyncStorage.removeItem(USER_STORAGE_KEY);
    } finally {
      setIsLoading(false);
    }
  };

  const signOut = async () => {
    try {
      // 1. Chama o authService para limpar o Token JWT (Tarefa 09)
      await authService.logout(); 
    } catch (error) {
      console.error("Erro ao limpar o token no logout:", error);
    } finally {
      // 2. ATUALIZA O ESTADO (O PASSO MAIS IMPORTANTE)
      setUser(null);
      // 3. Limpa os dados do utilizador do storage
      await AsyncStorage.removeItem(USER_STORAGE_KEY);
    }
  };

  return (
    <AuthContext.Provider value={{ isLoading, user, signIn, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};
```

-----

### 5\. (Frontend) `services/authService.ts`

**Tarefa:** Corrigir o `authService.ts` (como na Tarefa 08).

**Instru√ß√µes:**
**Substitua** o conte√∫do do `services/authService.ts` por isto:

```typescript
// Em: services/authService.ts
import { api } from './ixcApi'; // <--- Importa o NOVO 'api.ts'
import { API_CONFIG } from '@/constants/config';
import type { AuthUserData, IXCLoginRequest } from '@/types/ixc';

export const authService = {
  
  /**
   * Fun√ß√£o de login real.
   * Chama o *nosso backend* no Render.
   */
  async login(credentials: IXCLoginRequest): Promise<AuthUserData> {
    try {
      // O tipo de resposta esperado do nosso backend (server.js)
      type BackendAuthResponse = AuthUserData & { token: string };

      // 1. Chama o NOVO endpoint de login do *nosso backend*
      const response = await api.post<BackendAuthResponse>(
        API_CONFIG.ENDPOINTS.LOGIN, // Chama '/api/auth/login'
        credentials
      );

      // 2. O backend (server.js) retorna o nosso Token JWT e os dados do user
      if (response.token) {
        // 3. Salvamos o Token JWT no AsyncStorage (o 'api.ts' faz isso)
        await api.setToken(response.token);
      }
      
      // 4. Retorna os dados do utilizador para o AuthContext
      return response;

    } catch (error) {
      console.error('Erro no authService.login:', error);
      // Re-lan√ßa o erro para o AuthContext (Tarefa 12) poder mostr√°-lo
      if (axios.isAxiosError(error) && error.response) {
        throw new Error(error.response.data.error || 'Erro de rede');
      }
      throw error;
    }
  },

  /**
   * O Logout agora limpa o nosso Token JWT
   */
  async logout() {
    await api.clearToken();
  },
};
```

*(Nota: A fun√ß√£o `mockLogin` foi removida para garantir que apenas o login real seja usado).*

-----

### 6\. (Frontend) `docs/FIBERBOT_AI_GUIDE.md`

**Tarefa:** Remover "OnSpace AI" (Item 6).

**Instru√ß√µes:**
Abra `docs/FIBERBOT_AI_GUIDE.md` e apague a sec√ß√£o "Op√ß√£o 2: OnSpace AI (Gratuito)".