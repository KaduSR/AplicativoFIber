Compreendo perfeitamente a sua frustração. A sua lista de problemas está correta, mas a boa notícia é que todos esses erros estão interligados.

O seu aplicativo não está a funcionar (logout, botões, conexão) porque:

O nosso backend (server.js) (no Render) ainda não tem as rotas necessárias (para Notícias, Faturas, Contratos).

O nosso frontend (o aplicativo AplicativoFIber) ainda não foi "ligado" a esses novos endpoints.

O seu Chatbot (Gemini) não foi instruído a verificar o DownDetector.

Vamos corrigir TUDO isto agora, de uma vez por todas. Esta é a Tarefa 17, que irá consertar todas as pontas soltas.

Tarefa 17: Correção de Conectividade Total (Backend e Frontend)
Objetivo: Implementar todas as funcionalidades em falta no backend (server.js) e conectar o frontend (AplicativoFIber) a elas, resolvendo todos os problemas que listou (Logout, Botões, Notícias, Chatbot, Conexão).

1. Backend (backend/server.js)
Vamos adicionar a lógica que falta para Notícias, Faturas, Contratos e o DownDetector.

1. Instale as Novas Dependências (no Backend): (O axios já deve estar instalado, mas o cheerio é novo).

No seu terminal, na pasta backend (AplicativoFIber/backend), execute:

Bash

npm install cheerio
(Lembre-se de fazer git push do package.json e package-lock.json atualizados para o GitHub, para o Render instalar o cheerio).

2. Adicione as Novas Variáveis de Ambiente (no Render): Aceda ao painel do Render, vá a "Environment" e adicione:

Key: NEWS_API_KEY

Value: (Obtenha uma chave gratuita em gnews.io ou newsapi.org. Recomendo o GNews, pois é mais simples para os seus tópicos).

3. Adicione as Novas Importações (no topo do server.js):

JavaScript

// Em: backend/server.js

// ... (imports existentes de helmet, rateLimit, etc.)
const { GoogleGenerativeAI } = require("@google/generative-ai");

// --- MODIFIQUE ESTE BLOCO ---
const axios = require('axios');
const jwt = require('jsonwebtoken');
const base64 = require('react-native-base64');
const cheerio = require('cheerio'); // <-- ADICIONE PARA O DOWNDETECTOR
// --- FIM DA MODIFICAÇÃO ---

// ... (const app = express();)
4. Adicione as Novas Variáveis (no topo do server.js):

JavaScript

// Em: backend/server.js

// ... (inicialização do genAI)

// --- MODIFIQUE ESTE BLOCO ---
const IXC_API_URL = process.env.IXC_API_URL || 'https://centralfiber.online/webservice/v1';
const IXC_ADMIN_TOKEN = process.env.IXC_ADMIN_TOKEN; 
const JWT_SECRET = process.env.JWT_SECRET;
const NEWS_API_KEY = process.env.NEWS_API_KEY; // <-- ADICIONE ESTA LINHA
// --- FIM DA MODIFICAÇÃO ---

// ... (código do ixcApi e ixcPostList)
5. Substitua a Rota /api/bot (Correção do Chatbot/DownDetector): Substitua o seu app.post('/api/bot', ...) existente por este código melhorado:

JavaScript

// Em: backend/server.js

// --- SUBSTITUA A ROTA /api/bot ---
app.post('/api/bot', async (req, res, next) => {
  try {
    const { message, history } = req.body; // id_cliente não é necessário aqui ainda
    if (!process.env.GEMINI_API_KEY) throw new Error('Chave Gemini não configurada.');

    // --- LÓGICA DO DOWNDETECTOR (ITEM 5) ---
    let downDetectorInfo = "";
    // Verifica se a mensagem menciona um serviço (ex: Discord, Netflix, etc.)
    // Adicionámos 'discord' como você pediu.
    const servicos = ['discord', 'netflix', 'youtube', 'iptv', 'instagram', 'facebook', 'whatsapp'];
    const servicoMencionado = servicos.find(s => message.toLowerCase().includes(s));

    if (servicoMencionado) {
      console.log(`[Bot] Verificando DownDetector para: ${servicoMencionado}`);
      try {
        // Alternativa: Raspagem do site (Scraping)
        const { data } = await axios.get(`https://downdetector.com.br/fora-do-ar/${servicoMencionado}/`);
        const $ = cheerio.load(data);
        // Tenta pegar o status. Ex: "Problemas com Discord"
        const status = $('.entry-title').first().text().trim();
        if (status && !status.toLowerCase().includes("nenhum problema")) {
          downDetectorInfo = `Contexto Externo: O DownDetector está a reportar "${status}".`;
        } else {
          downDetectorInfo = `Contexto Externo: O DownDetector indica que ${servicoMencionado} está a funcionar normalmente.`;
        }
      } catch (scrapeError) {
        console.error("[Bot] Falha ao raspar DownDetector:", scrapeError.message);
        downDetectorInfo = `Contexto Externo: Não consegui verificar o status do ${servicoMencionado}.`;
      }
    }
    // --- FIM DA LÓGICA DOWNDETECTOR ---

    // (Contexto Fixo - idealmente viria do /api/ont e /api/contracts)
    const userContext = {
      nome: "Cliente",
      plano: "FiberNet",
      sinal_optico: "Ideal" 
    };

    const systemPrompt = `
[Persona]
Aja como o 'FiberBot', um assistente técnico especialista da FiberNet.

[Contexto do Cliente]
- Nome: ${userContext.nome}
- Plano: ${userContext.plano}
- Sinal Óptico (ONT): ${userContext.sinal_optico}
- ${downDetectorInfo || "Nenhuma informação externa solicitada."}

[Tarefa]
Diagnostique o problema do cliente com base no contexto.

[Instruções]
- Se o cliente perguntar sobre 'Discord', 'Netflix', 'IPTV', etc., use a informação do 'Contexto Externo' (DownDetector) para informar se o problema é geral.
- Se o 'Contexto Externo' disser que há problemas, informe o cliente que o problema é no serviço (ex: Discord) e não na FiberNet.
`;

    // (O resto da chamada ao Gemini continua igual)
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const chatHistory = history.map(msg => ({
      role: msg.role === 'user' ? 'user' : 'model',
      parts: [{ text: msg.content }],
    }));
    const chat = model.startChat({ history: chatHistory, systemInstruction: systemPrompt });
    const result = await chat.sendMessage(message);
    const text = result.response.text();
    res.json({ reply: text });

  } catch (error) {
    next(error);
  }
});
// --- FIM DA SUBSTITUIÇÃO ---
6. Adicione as Novas Rotas (Notícias, Faturas, Contratos): Adicione este bloco depois da sua rota /api/speedtest e antes do "404 handler":

JavaScript

// Em: backend/server.js

// ... (depois da rota /api/speedtest)

// --- ROTA DE NOTÍCIAS (ITEM 4) ---
app.get('/api/news', async (req, res, next) => {
  if (!NEWS_API_KEY) {
    return next(new Error("API de Notícias não configurada no servidor."));
  }
  try {
    // Tópicos: IPTV, Jogos, Tecnologia, Fibra Óptica, Séries e Filmes
    const query = "IPTV OR gaming OR technology OR 'fibra óptica' OR series OR movies";
    // Usando a API GNews.io (substitua 'newsapi.org' se preferir)
    const url = `https://gnews.io/api/v4/search?q=${encodeURIComponent(query)}&lang=pt&apikey=${NEWS_API_KEY}`;
    
    const { data } = await axios.get(url);
    res.json(data.articles || []);
  
  } catch (error) {
    console.error("Erro ao buscar notícias:", error.response?.data || error.message);
    next(error);
  }
});

// --- ROTAS PROTEGIDAS (Precisam de JWT) ---
// Middleware para verificar o nosso Token JWT
const checkAuth = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Token não fornecido.' });
  }
  const token = authHeader.split(' ')[1];
  try {
    // O JWT_SECRET que definimos no Render
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded; // Adiciona os dados (id_cliente, etc.) ao 'req'
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Token inválido.' });
  }
};

// --- ROTA DE FATURAS (ITEM 2) ---
app.get('/api/invoices', checkAuth, async (req, res, next) => {
  try {
    const requestBody = {
      qtype: 'fn_areceber.id_cliente',
      query: req.user.id_cliente, // Pega o ID do cliente (do JWT)
      oper: '=',
      page: '1', rp: '50',
      sortname: 'fn_areceber.data_vencimento', sortorder: 'desc',
    };
    const data = await ixcPostList('/fn_areceber', requestBody);
    res.json(data.registros || []);
  } catch (error) { next(error); }
});

// --- ROTA DE CONTRATOS (ITEM 2) ---
app.get('/api/contracts', checkAuth, async (req, res, next) => {
  try {
    const requestBody = {
      qtype: 'cliente_contrato.id_cliente',
      query: req.user.id_cliente, // Pega o ID do cliente (do JWT)
      oper: '=',
      page: '1', rp: '10',
      sortname: 'cliente_contrato.id', sortorder: 'desc',
    };
    const data = await ixcPostList('/cliente_contrato', requestBody);
    res.json(data.registros || []);
  } catch (error) { next(error); }
});


// 404 handler (Sempre por último...)
// ...
2. Frontend (constants/config.ts)
Tarefa: Adicionar os novos endpoints ao API_CONFIG.

Instruções: Substitua o seu API_CONFIG em constants/config.ts por isto:

TypeScript

// Em: constants/config.ts

// ... (API_BASE_URL permanece a mesma)

export const API_CONFIG = {
  BASE_URL: API_BASE_URL,
  
  ENDPOINTS: {
    // Autenticação
    LOGIN: '/api/auth/login',

    // Rotas do IXC (Item 2)
    INVOICES: '/api/invoices',     // <-- ADICIONADO
    CONTRACTS: '/api/contracts',    // <-- ADICIONADO
    BOLETO: '/api/boleto',        // (Já existia na Tarefa 02)
    
    // Rotas de Serviços
    ONT: '/api/ont',              // (Item 7)
    BOT: '/api/bot',              // (Item 5)
    SPEEDTEST: '/api/speedtest',
    NEWS: '/api/news',            // <-- ADICIONADO (Item 4)
  }
};
3. Frontend (app/(tabs)/conexao.tsx)
Tarefa: Ligar a tela de "Conexão" (Item 7).

Instruções: Substitua o conteúdo do seu app/(tabs)/conexao.tsx por este código:

TypeScript

// Em: app/(tabs)/conexao.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, ActivityIndicator, Alert, StyleSheet } from 'react-native';
import { api } from '@/services/ixcApi';
import { API_CONFIG } from '@/constants/config';

export default function ConexaoScreen() {
  const [ontStatus, setOntStatus] = useState(null);
  const [speedTestResult, setSpeedTestResult] = useState(null);
  const [isLoadingOnt, setIsLoadingOnt] = useState(false);
  const [isLoadingSpeed, setIsLoadingSpeed] = useState(false);

  // Função para buscar status da ONT (GenieACS)
  const fetchOntStatus = async () => {
    setIsLoadingOnt(true);
    try {
      // (Nota: O endpoint '/api/ont' precisa do 'serial' do cliente)
      // (Como ainda não temos isso, vamos simular a chamada)
      // const data = await api.get(`${API_CONFIG.ENDPOINTS.ONT}/SEU_SERIAL_AQUI`);
      // setOntStatus(data);
      
      // Simulação (remova isto quando o '/api/ont' estiver a funcionar com o serial)
      await new Promise(resolve => setTimeout(resolve, 500));
      setOntStatus({ signal: '-22.5 dBm', status: 'Online' });

    } catch (error) {
      Alert.alert("Erro ONT", "Não foi possível buscar o status da ONT.");
    } finally {
      setIsLoadingOnt(false);
    }
  };

  // Função para rodar o Speedtest (Backend)
  const runSpeedTest = async () => {
    setIsLoadingSpeed(true);
    setSpeedTestResult(null);
    try {
      const data = await api.get(API_CONFIG.ENDPOINTS.SPEEDTEST);
      setSpeedTestResult(data);
    } catch (error) {
      Alert.alert("Erro Speedtest", "Não foi possível completar o teste de velocidade.");
    } finally {
      setIsLoadingSpeed(false);
    }
  };

  // Carrega o status da ONT ao abrir a tela
  useEffect(() => {
    fetchOntStatus();
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Minha Conexão</Text>

      {/* Status da ONT */}
      <View style={styles.card}>
        <Text style={styles.cardTitle}>Status do Equipamento (ONT)</Text>
        {isLoadingOnt ? (
          <ActivityIndicator />
        ) : (
          <>
            <Text>Sinal Óptico: {ontStatus?.signal || 'N/A'}</Text>
            <Text>Status: {ontStatus?.status || 'N/A'}</Text>
          </>
        )}
      </View>

      {/* Teste de Velocidade */}
      <View style={styles.card}>
        <Text style={styles.cardTitle}>Teste de Velocidade</Text>
        {isLoadingSpeed ? (
          <ActivityIndicator size="large" />
        ) : (
          <>
            <Text>Download: {speedTestResult?.download || '0.00'} Mbps</Text>
            <Text>Upload: {speedTestResult?.upload || '0.00'} Mbps</Text>
            <Text>Ping: {speedTestResult?.ping || '0'} ms</Text>
          </>
        )}
        <Button 
          title={isLoadingSpeed ? "Testando..." : "Iniciar Teste"}
          onPress={runSpeedTest} 
          disabled={isLoadingSpeed}
        />
        {speedTestResult?.resultUrl && (
          <Text style={{fontSize: 12, color: 'blue', marginTop: 5}}>Ver resultado completo</Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, backgroundColor: '#f0f0f0' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20 },
  card: { backgroundColor: '#fff', padding: 15, borderRadius: 8, marginBottom: 20 },
  cardTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 10 },
});
4. Frontend (app/(tabs)/perfil.tsx)
Tarefa: Corrigir os botões de logout e navegação (Item 1, 2, 3).

Instruções: Substitua o conteúdo do seu app/(tabs)/perfil.tsx pelo layout correto, com os botões ligados.

TypeScript

// Em: app/(tabs)/perfil.tsx
import React from 'react';
import { View, Text, Button, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { useAuth } from '@/hooks/useAuth';
import { useRouter } from 'expo-router'; // Importa o hook de navegação

export default function PerfilScreen() {
  const { user, signOut } = useAuth(); // Pega o 'user' e 'signOut'
  const router = useRouter(); // Inicializa o router

  const handleLogout = () => {
    // Chama o 'signOut' (Tarefa 09/11)
    signOut(); 
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.headerTitle}>Meu Perfil</Text>

      {/* Bloco de Avatar e Nome (Simulado) */}
      <View style={styles.profileHeader}>
        <View style={styles.avatar}>
          <Text style={styles.avatarText}>{user?.nome_cliente?.charAt(0) || 'U'}</Text>
        </View>
        <Text style={styles.profileName}>{user?.nome_cliente || 'Carregando...'}</Text>
        <Text style={styles.profileEmail}>{user?.email || '...'}</Text>
      </View>

      {/* Menu de Botões (Item 2) */}
      <View style={styles.menuContainer}>
        {/* (Estes são exemplos, adicione ícones se quiser) */}
        
        <TouchableOpacity style={styles.menuButton} onPress={() => router.push('/(tabs)/meus-dados')}>
          <Text style={styles.menuButtonText}>Meus Dados</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.menuButton} onPress={() => router.push('/(tabs)/meus-contratos')}>
          <Text style={styles.menuButtonText}>Meus Contratos</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.menuButton} onPress={() => router.push('/(tabs)/minhas-faturas')}>
          <Text style={styles.menuButtonText}>Minhas Faturas</Text>
        </TouchableOpacity>

        <TouchableOpacity style={styles.menuButton} onPress={() => router.push('/(tabs)/notificacoes')}>
          <Text style={styles.menuButtonText}>Notificações</Text>
        </TouchableOpacity>

        {/* O botão "Meus Cartões" foi removido (Item 3) */}
      </View>

      {/* Botão de Sair (Item 1) */}
      <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
        <Text style={styles.logoutButtonText}>Sair da Conta</Text>
      </TouchableOpacity>
    </ScrollView>
  );
}

// Estilos baseados nas suas imagens
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  headerTitle: { fontSize: 22, fontWeight: 'bold', textAlign: 'center', marginVertical: 20 },
  profileHeader: { alignItems: 'center', marginBottom: 30 },
  avatar: { 
    width: 100, height: 100, borderRadius: 50, 
    backgroundColor: '#eee', justifyContent: 'center', alignItems: 'center',
    marginBottom: 15,
  },
  avatarText: { fontSize: 40, color: '#888' },
  profileName: { fontSize: 20, fontWeight: 'bold' },
  profileEmail: { fontSize: 16, color: '#666' },
  menuContainer: { marginHorizontal: 20 },
  menuButton: { 
    backgroundColor: '#f9f9f9', padding: 20, 
    borderRadius: 10, marginBottom: 10,
    flexDirection: 'row', alignItems: 'center' 
  },
  menuButtonText: { fontSize: 16, flex: 1 },
  logoutButton: { 
    margin: 20, padding: 15, 
    alignItems: 'center', backgroundColor: '#FFF0F0' ,
    borderRadius: 10
  },
  logoutButtonText: { color: '#FF3B30', fontSize: 16, fontWeight: 'bold' }
});
5. Frontend (app/(tabs)/noticias.tsx)
Tarefa: Ligar a tela de "Notícias" (Item 4).

Instruções: Substitua o conteúdo do seu app/(tabs)/noticias.tsx por este código:

TypeScript

// Em: app/(tabs)/noticias.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, ActivityIndicator, Alert, StyleSheet, TouchableOpacity, Linking } from 'react-native';
import { api } from '@/services/ixcApi';
import { API_CONFIG } from '@/constants/config';

export default function NoticiasScreen() {
  const [articles, setArticles] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  const fetchNews = async () => {
    setIsLoading(true);
    try {
      const data = await api.get(API_CONFIG.ENDPOINTS.NEWS);
      setArticles(data);
    } catch (error) {
      Alert.alert("Erro", "Não foi possível carregar as notícias.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchNews();
  }, []);

  const openArticle = (url) => {
    Linking.openURL(url);
  };

  if (isLoading) {
    return <View style={styles.container}><ActivityIndicator size="large" /></View>;
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Últimas Notícias</Text>
      <FlatList
        data={articles}
        keyExtractor={(item, index) => item.url || index.toString()}
        renderItem={({ item }) => (
          <TouchableOpacity style={styles.card} onPress={() => openArticle(item.url)}>
            <Text style={styles.cardTitle}>{item.title}</Text>
            <Text style={styles.cardSource}>{item.source.name}</Text>
          </TouchableOpacity>
        )}
        onRefresh={fetchNews}
        refreshing={isLoading}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 10, backgroundColor: '#f0f0f0' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, paddingHorizontal: 10 },
  card: { backgroundColor: '#fff', padding: 15, borderRadius: 8, marginBottom: 10 },
  cardTitle: { fontSize: 16, fontWeight: 'bold' },
  cardSource: { fontSize: 12, color: '#666', marginTop: 5 },
});